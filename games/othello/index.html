<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Othello - WEB GAME PORTFOLIO</title>
  <style>
    :root {
      --board-bg: #0d7a3e;
      --board-line: #0a5f2f;
      --cell-size: min(10vmin, 60px);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Helvetica Neue", "Segoe UI", Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .back-link {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: rgba(255, 255, 255, 0.6);
      text-decoration: none;
      font-size: 0.85rem;
      letter-spacing: 0.1em;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #fff;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 1rem;
      text-transform: uppercase;
    }

    .game-info {
      display: flex;
      gap: 2rem;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .score {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .score-disc {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #444;
    }

    .score-disc--black {
      background: #111;
    }

    .score-disc--white {
      background: #eee;
    }

    .current-turn {
      padding: 0.3rem 0.8rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, var(--cell-size));
      grid-template-rows: repeat(8, var(--cell-size));
      background: var(--board-bg);
      border: 4px solid #0a4f2a;
      border-radius: 4px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid var(--board-line);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
    }

    .cell:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .cell.valid-move::after {
      content: '';
      width: 30%;
      height: 30%;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
    }

    .disc {
      width: 80%;
      height: 80%;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .disc--black {
      background: radial-gradient(circle at 30% 30%, #444, #111);
    }

    .disc--white {
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }

    .disc.flip {
      animation: flip 0.4s ease;
    }

    @keyframes flip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg) scale(1.1); }
      100% { transform: rotateY(0deg); }
    }

    .game-controls {
      margin-top: 1.5rem;
      display: flex;
      gap: 1rem;
    }

    button {
      padding: 0.6rem 1.5rem;
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.5);
    }

    select {
      padding: 0.6rem 1rem;
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    select:hover {
      border-color: rgba(255, 255, 255, 0.5);
    }

    /* Combo display */
    .combo-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      font-weight: 700;
      text-transform: uppercase;
      pointer-events: none;
      opacity: 0;
      z-index: 100;
      text-shadow: 0 0 20px currentColor;
    }

    .combo-display.show {
      animation: comboPopup 1s ease-out forwards;
    }

    .combo-display.nice { color: #4ade80; }
    .combo-display.great { color: #facc15; }
    .combo-display.amazing { color: #f97316; }
    .combo-display.incredible { color: #ec4899; }

    @keyframes comboPopup {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      40% {
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -60%) scale(1);
      }
    }

    /* Particles */
    .particle {
      position: fixed;
      pointer-events: none;
      border-radius: 50%;
      z-index: 99;
    }

    @keyframes particleFly {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0);
      }
    }

    .message {
      margin-top: 1rem;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      min-height: 1.5em;
    }

    .game-over {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .game-over.show {
      opacity: 1;
      pointer-events: auto;
    }

    .game-over h2 {
      font-size: 2rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 1rem;
    }

    .game-over p {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>
  <a href="../../" class="back-link">Back to Portfolio</a>

  <h1>Othello</h1>

  <div class="game-info">
    <div class="score">
      <div class="score-disc score-disc--black"></div>
      <span id="black-score">2</span>
    </div>
    <div class="current-turn" id="turn-indicator">Black's Turn</div>
    <div class="score">
      <div class="score-disc score-disc--white"></div>
      <span id="white-score">2</span>
    </div>
  </div>

  <div class="board" id="board"></div>

  <div class="game-controls">
    <button id="reset-btn">New Game</button>
    <button id="cpu-toggle">CPU: ON</button>
    <select id="difficulty-select">
      <option value="easy">Easy</option>
      <option value="normal" selected>Normal</option>
      <option value="hard">Hard</option>
    </select>
  </div>

  <p class="message" id="message"></p>

  <div class="combo-display" id="combo-display"></div>

  <div class="game-over" id="game-over">
    <h2 id="winner-text">Game Over</h2>
    <p id="final-score">Black: 32 - White: 32</p>
    <button id="play-again-btn">Play Again</button>
  </div>

  <script>
    const EMPTY = 0, BLACK = 1, WHITE = 2;
    const DIRECTIONS = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],          [0, 1],
      [1, -1],  [1, 0], [1, 1]
    ];

    let board = [];
    let currentPlayer = BLACK;
    let cpuEnabled = true;
    let gameActive = true;
    let difficulty = 'normal';

    const boardEl = document.getElementById('board');
    const blackScoreEl = document.getElementById('black-score');
    const whiteScoreEl = document.getElementById('white-score');
    const turnIndicator = document.getElementById('turn-indicator');
    const messageEl = document.getElementById('message');
    const gameOverEl = document.getElementById('game-over');
    const winnerTextEl = document.getElementById('winner-text');
    const finalScoreEl = document.getElementById('final-score');
    const cpuToggleBtn = document.getElementById('cpu-toggle');
    const difficultySelect = document.getElementById('difficulty-select');
    const comboDisplay = document.getElementById('combo-display');

    function initBoard() {
      board = Array(8).fill(null).map(() => Array(8).fill(EMPTY));
      board[3][3] = WHITE;
      board[3][4] = BLACK;
      board[4][3] = BLACK;
      board[4][4] = WHITE;
      currentPlayer = BLACK;
      gameActive = true;
      gameOverEl.classList.remove('show');
      messageEl.textContent = '';
      renderBoard();
      updateScore();
      updateTurnIndicator();
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      const validMoves = getValidMoves(currentPlayer);

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;

          if (board[row][col] !== EMPTY) {
            const disc = document.createElement('div');
            disc.className = `disc disc--${board[row][col] === BLACK ? 'black' : 'white'}`;
            cell.appendChild(disc);
          } else if (validMoves.some(m => m.row === row && m.col === col)) {
            cell.classList.add('valid-move');
          }

          cell.addEventListener('click', () => handleCellClick(row, col));
          boardEl.appendChild(cell);
        }
      }
    }

    function getValidMoves(player) {
      const moves = [];
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === EMPTY && getFlippableDiscs(row, col, player).length > 0) {
            moves.push({ row, col });
          }
        }
      }
      return moves;
    }

    function getFlippableDiscs(row, col, player) {
      const opponent = player === BLACK ? WHITE : BLACK;
      const flippable = [];

      for (const [dr, dc] of DIRECTIONS) {
        const line = [];
        let r = row + dr, c = col + dc;

        while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
          line.push({ row: r, col: c });
          r += dr;
          c += dc;
        }

        if (line.length > 0 && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
          flippable.push(...line);
        }
      }

      return flippable;
    }

    function handleCellClick(row, col) {
      if (!gameActive || board[row][col] !== EMPTY) return;
      if (cpuEnabled && currentPlayer === WHITE) return;

      makeMove(row, col, currentPlayer);
    }

    function makeMove(row, col, player) {
      const flippable = getFlippableDiscs(row, col, player);
      if (flippable.length === 0) return false;

      board[row][col] = player;
      flippable.forEach(({ row: r, col: c }) => {
        board[r][c] = player;
      });

      renderBoard();
      animateFlip(flippable);
      updateScore();

      // Show combo and particles for good moves
      if (flippable.length >= 3) {
        showCombo(flippable.length);
        createParticles(flippable, player);
      }

      setTimeout(() => {
        switchTurn();
      }, 300);

      return true;
    }

    function animateFlip(positions) {
      positions.forEach(({ row, col }) => {
        const cellIndex = row * 8 + col;
        const disc = boardEl.children[cellIndex].querySelector('.disc');
        if (disc) disc.classList.add('flip');
      });
    }

    function showCombo(flipsCount) {
      let text = '';
      let className = '';

      if (flipsCount >= 10) {
        text = 'INCREDIBLE!';
        className = 'incredible';
      } else if (flipsCount >= 7) {
        text = 'AMAZING!';
        className = 'amazing';
      } else if (flipsCount >= 5) {
        text = 'GREAT!';
        className = 'great';
      } else if (flipsCount >= 3) {
        text = 'NICE!';
        className = 'nice';
      }

      if (text) {
        comboDisplay.textContent = text;
        comboDisplay.className = 'combo-display ' + className;
        void comboDisplay.offsetWidth;
        comboDisplay.classList.add('show');

        setTimeout(() => {
          comboDisplay.classList.remove('show');
        }, 1000);
      }
    }

    function createParticles(positions, player) {
      const colors = player === BLACK
        ? ['#333', '#555', '#777', '#4ade80', '#22c55e']
        : ['#fff', '#eee', '#ddd', '#facc15', '#fbbf24'];

      positions.forEach(({ row, col }) => {
        const cellIndex = row * 8 + col;
        const cell = boardEl.children[cellIndex];
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const particleCount = Math.min(positions.length, 5);

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';

          const size = Math.random() * 8 + 4;
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 60 + 40;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;

          particle.style.cssText = `
            width: ${size}px;
            height: ${size}px;
            left: ${centerX - size/2}px;
            top: ${centerY - size/2}px;
            background: ${colors[Math.floor(Math.random() * colors.length)]};
            --tx: ${tx}px;
            --ty: ${ty}px;
            animation: particleFly ${Math.random() * 0.3 + 0.5}s ease-out forwards;
          `;

          document.body.appendChild(particle);

          setTimeout(() => particle.remove(), 800);
        }
      });
    }

    function switchTurn() {
      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      const validMoves = getValidMoves(currentPlayer);

      if (validMoves.length === 0) {
        currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        const otherMoves = getValidMoves(currentPlayer);

        if (otherMoves.length === 0) {
          endGame();
          return;
        }

        messageEl.textContent = `${currentPlayer === BLACK ? 'White' : 'Black'} has no valid moves. Skipped.`;
      } else {
        messageEl.textContent = '';
      }

      updateTurnIndicator();
      renderBoard();

      if (cpuEnabled && currentPlayer === WHITE && gameActive) {
        setTimeout(cpuMove, 500);
      }
    }

    // Position weights for strategic evaluation
    const POSITION_WEIGHTS = [
      [100, -20,  10,   5,   5,  10, -20, 100],
      [-20, -50,  -2,  -2,  -2,  -2, -50, -20],
      [ 10,  -2,   1,   1,   1,   1,  -2,  10],
      [  5,  -2,   1,   0,   0,   1,  -2,   5],
      [  5,  -2,   1,   0,   0,   1,  -2,   5],
      [ 10,  -2,   1,   1,   1,   1,  -2,  10],
      [-20, -50,  -2,  -2,  -2,  -2, -50, -20],
      [100, -20,  10,   5,   5,  10, -20, 100]
    ];

    function evaluateBoard(player) {
      let score = 0;
      const opponent = player === BLACK ? WHITE : BLACK;

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === player) {
            score += POSITION_WEIGHTS[row][col];
          } else if (board[row][col] === opponent) {
            score -= POSITION_WEIGHTS[row][col];
          }
        }
      }

      return score;
    }

    function minimax(depth, isMaximizing, alpha, beta) {
      const player = isMaximizing ? WHITE : BLACK;
      const validMoves = getValidMoves(player);

      if (depth === 0 || validMoves.length === 0) {
        return evaluateBoard(WHITE);
      }

      if (isMaximizing) {
        let maxEval = -Infinity;
        for (const move of validMoves) {
          const savedBoard = board.map(row => [...row]);
          const flippable = getFlippableDiscs(move.row, move.col, player);

          board[move.row][move.col] = player;
          flippable.forEach(({ row: r, col: c }) => {
            board[r][c] = player;
          });

          const evalScore = minimax(depth - 1, false, alpha, beta);
          board = savedBoard;

          maxEval = Math.max(maxEval, evalScore);
          alpha = Math.max(alpha, evalScore);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of validMoves) {
          const savedBoard = board.map(row => [...row]);
          const flippable = getFlippableDiscs(move.row, move.col, player);

          board[move.row][move.col] = player;
          flippable.forEach(({ row: r, col: c }) => {
            board[r][c] = player;
          });

          const evalScore = minimax(depth - 1, true, alpha, beta);
          board = savedBoard;

          minEval = Math.min(minEval, evalScore);
          beta = Math.min(beta, evalScore);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function cpuMove() {
      const validMoves = getValidMoves(WHITE);
      if (validMoves.length === 0) return;

      let bestMove;

      if (difficulty === 'easy') {
        // Easy: Random move with slight preference for more flips
        const weights = validMoves.map(move => {
          const flips = getFlippableDiscs(move.row, move.col, WHITE).length;
          return Math.random() + flips * 0.1;
        });
        const maxWeight = Math.max(...weights);
        bestMove = validMoves[weights.indexOf(maxWeight)];

      } else if (difficulty === 'normal') {
        // Normal: Greedy with corner priority
        let maxScore = -Infinity;
        validMoves.forEach(move => {
          const flips = getFlippableDiscs(move.row, move.col, WHITE).length;
          const positionBonus = POSITION_WEIGHTS[move.row][move.col];
          const score = flips * 2 + positionBonus;
          if (score > maxScore) {
            maxScore = score;
            bestMove = move;
          }
        });

      } else {
        // Hard: Minimax with alpha-beta pruning
        let maxScore = -Infinity;
        const searchDepth = 4;

        for (const move of validMoves) {
          const savedBoard = board.map(row => [...row]);
          const flippable = getFlippableDiscs(move.row, move.col, WHITE);

          board[move.row][move.col] = WHITE;
          flippable.forEach(({ row: r, col: c }) => {
            board[r][c] = WHITE;
          });

          const score = minimax(searchDepth - 1, false, -Infinity, Infinity);
          board = savedBoard;

          if (score > maxScore) {
            maxScore = score;
            bestMove = move;
          }
        }
      }

      makeMove(bestMove.row, bestMove.col, WHITE);
    }

    function updateScore() {
      let black = 0, white = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) black++;
          else if (cell === WHITE) white++;
        });
      });
      blackScoreEl.textContent = black;
      whiteScoreEl.textContent = white;
    }

    function updateTurnIndicator() {
      turnIndicator.textContent = currentPlayer === BLACK ? "Black's Turn" : "White's Turn";
    }

    function endGame() {
      gameActive = false;
      const black = parseInt(blackScoreEl.textContent);
      const white = parseInt(whiteScoreEl.textContent);

      if (black > white) {
        winnerTextEl.textContent = 'Black Wins!';
      } else if (white > black) {
        winnerTextEl.textContent = 'White Wins!';
      } else {
        winnerTextEl.textContent = "It's a Draw!";
      }

      finalScoreEl.textContent = `Black: ${black} - White: ${white}`;
      gameOverEl.classList.add('show');
    }

    document.getElementById('reset-btn').addEventListener('click', initBoard);
    document.getElementById('play-again-btn').addEventListener('click', initBoard);
    cpuToggleBtn.addEventListener('click', () => {
      cpuEnabled = !cpuEnabled;
      cpuToggleBtn.textContent = `CPU: ${cpuEnabled ? 'ON' : 'OFF'}`;
    });
    difficultySelect.addEventListener('change', (e) => {
      difficulty = e.target.value;
    });

    initBoard();
  </script>
</body>
</html>
