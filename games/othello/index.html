<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Othello - WEB GAME PORTFOLIO</title>
  <style>
    :root {
      --board-bg: #0d7a3e;
      --board-line: #0a5f2f;
      --cell-size: min(10vmin, 60px);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Helvetica Neue", "Segoe UI", Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .back-link {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: rgba(255, 255, 255, 0.6);
      text-decoration: none;
      font-size: 0.85rem;
      letter-spacing: 0.1em;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #fff;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 1rem;
      text-transform: uppercase;
    }

    .game-info {
      display: flex;
      gap: 2rem;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .score {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .score-disc {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #444;
    }

    .score-disc--black {
      background: #111;
    }

    .score-disc--white {
      background: #eee;
    }

    .current-turn {
      padding: 0.3rem 0.8rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, var(--cell-size));
      grid-template-rows: repeat(8, var(--cell-size));
      background: var(--board-bg);
      border: 4px solid #0a4f2a;
      border-radius: 4px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 1px solid var(--board-line);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
    }

    .cell:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .cell.valid-move::after {
      content: '';
      width: 30%;
      height: 30%;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
    }

    .disc {
      width: 80%;
      height: 80%;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .disc--black {
      background: radial-gradient(circle at 30% 30%, #444, #111);
    }

    .disc--white {
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }

    .disc.flip {
      animation: flip 0.4s ease;
    }

    @keyframes flip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg) scale(1.1); }
      100% { transform: rotateY(0deg); }
    }

    .game-controls {
      margin-top: 1.5rem;
      display: flex;
      gap: 1rem;
    }

    button {
      padding: 0.6rem 1.5rem;
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .message {
      margin-top: 1rem;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      min-height: 1.5em;
    }

    .game-over {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .game-over.show {
      opacity: 1;
      pointer-events: auto;
    }

    .game-over h2 {
      font-size: 2rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 1rem;
    }

    .game-over p {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>
  <a href="../../" class="back-link">Back to Portfolio</a>

  <h1>Othello</h1>

  <div class="game-info">
    <div class="score">
      <div class="score-disc score-disc--black"></div>
      <span id="black-score">2</span>
    </div>
    <div class="current-turn" id="turn-indicator">Black's Turn</div>
    <div class="score">
      <div class="score-disc score-disc--white"></div>
      <span id="white-score">2</span>
    </div>
  </div>

  <div class="board" id="board"></div>

  <div class="game-controls">
    <button id="reset-btn">New Game</button>
    <button id="cpu-toggle">CPU: ON</button>
  </div>

  <p class="message" id="message"></p>

  <div class="game-over" id="game-over">
    <h2 id="winner-text">Game Over</h2>
    <p id="final-score">Black: 32 - White: 32</p>
    <button id="play-again-btn">Play Again</button>
  </div>

  <script>
    const EMPTY = 0, BLACK = 1, WHITE = 2;
    const DIRECTIONS = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],          [0, 1],
      [1, -1],  [1, 0], [1, 1]
    ];

    let board = [];
    let currentPlayer = BLACK;
    let cpuEnabled = true;
    let gameActive = true;

    const boardEl = document.getElementById('board');
    const blackScoreEl = document.getElementById('black-score');
    const whiteScoreEl = document.getElementById('white-score');
    const turnIndicator = document.getElementById('turn-indicator');
    const messageEl = document.getElementById('message');
    const gameOverEl = document.getElementById('game-over');
    const winnerTextEl = document.getElementById('winner-text');
    const finalScoreEl = document.getElementById('final-score');
    const cpuToggleBtn = document.getElementById('cpu-toggle');

    function initBoard() {
      board = Array(8).fill(null).map(() => Array(8).fill(EMPTY));
      board[3][3] = WHITE;
      board[3][4] = BLACK;
      board[4][3] = BLACK;
      board[4][4] = WHITE;
      currentPlayer = BLACK;
      gameActive = true;
      gameOverEl.classList.remove('show');
      messageEl.textContent = '';
      renderBoard();
      updateScore();
      updateTurnIndicator();
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      const validMoves = getValidMoves(currentPlayer);

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;

          if (board[row][col] !== EMPTY) {
            const disc = document.createElement('div');
            disc.className = `disc disc--${board[row][col] === BLACK ? 'black' : 'white'}`;
            cell.appendChild(disc);
          } else if (validMoves.some(m => m.row === row && m.col === col)) {
            cell.classList.add('valid-move');
          }

          cell.addEventListener('click', () => handleCellClick(row, col));
          boardEl.appendChild(cell);
        }
      }
    }

    function getValidMoves(player) {
      const moves = [];
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === EMPTY && getFlippableDiscs(row, col, player).length > 0) {
            moves.push({ row, col });
          }
        }
      }
      return moves;
    }

    function getFlippableDiscs(row, col, player) {
      const opponent = player === BLACK ? WHITE : BLACK;
      const flippable = [];

      for (const [dr, dc] of DIRECTIONS) {
        const line = [];
        let r = row + dr, c = col + dc;

        while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
          line.push({ row: r, col: c });
          r += dr;
          c += dc;
        }

        if (line.length > 0 && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
          flippable.push(...line);
        }
      }

      return flippable;
    }

    function handleCellClick(row, col) {
      if (!gameActive || board[row][col] !== EMPTY) return;
      if (cpuEnabled && currentPlayer === WHITE) return;

      makeMove(row, col, currentPlayer);
    }

    function makeMove(row, col, player) {
      const flippable = getFlippableDiscs(row, col, player);
      if (flippable.length === 0) return false;

      board[row][col] = player;
      flippable.forEach(({ row: r, col: c }) => {
        board[r][c] = player;
      });

      renderBoard();
      animateFlip(flippable);
      updateScore();

      setTimeout(() => {
        switchTurn();
      }, 300);

      return true;
    }

    function animateFlip(positions) {
      positions.forEach(({ row, col }) => {
        const cellIndex = row * 8 + col;
        const disc = boardEl.children[cellIndex].querySelector('.disc');
        if (disc) disc.classList.add('flip');
      });
    }

    function switchTurn() {
      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      const validMoves = getValidMoves(currentPlayer);

      if (validMoves.length === 0) {
        currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        const otherMoves = getValidMoves(currentPlayer);

        if (otherMoves.length === 0) {
          endGame();
          return;
        }

        messageEl.textContent = `${currentPlayer === BLACK ? 'White' : 'Black'} has no valid moves. Skipped.`;
      } else {
        messageEl.textContent = '';
      }

      updateTurnIndicator();
      renderBoard();

      if (cpuEnabled && currentPlayer === WHITE && gameActive) {
        setTimeout(cpuMove, 500);
      }
    }

    function cpuMove() {
      const validMoves = getValidMoves(WHITE);
      if (validMoves.length === 0) return;

      // Simple AI: pick move that flips most discs
      let bestMove = validMoves[0];
      let maxFlips = 0;

      validMoves.forEach(move => {
        const flips = getFlippableDiscs(move.row, move.col, WHITE).length;
        // Prioritize corners
        const isCorner = (move.row === 0 || move.row === 7) && (move.col === 0 || move.col === 7);
        const score = flips + (isCorner ? 100 : 0);
        if (score > maxFlips) {
          maxFlips = score;
          bestMove = move;
        }
      });

      makeMove(bestMove.row, bestMove.col, WHITE);
    }

    function updateScore() {
      let black = 0, white = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) black++;
          else if (cell === WHITE) white++;
        });
      });
      blackScoreEl.textContent = black;
      whiteScoreEl.textContent = white;
    }

    function updateTurnIndicator() {
      turnIndicator.textContent = currentPlayer === BLACK ? "Black's Turn" : "White's Turn";
    }

    function endGame() {
      gameActive = false;
      const black = parseInt(blackScoreEl.textContent);
      const white = parseInt(whiteScoreEl.textContent);

      if (black > white) {
        winnerTextEl.textContent = 'Black Wins!';
      } else if (white > black) {
        winnerTextEl.textContent = 'White Wins!';
      } else {
        winnerTextEl.textContent = "It's a Draw!";
      }

      finalScoreEl.textContent = `Black: ${black} - White: ${white}`;
      gameOverEl.classList.add('show');
    }

    document.getElementById('reset-btn').addEventListener('click', initBoard);
    document.getElementById('play-again-btn').addEventListener('click', initBoard);
    cpuToggleBtn.addEventListener('click', () => {
      cpuEnabled = !cpuEnabled;
      cpuToggleBtn.textContent = `CPU: ${cpuEnabled ? 'ON' : 'OFF'}`;
    });

    initBoard();
  </script>
</body>
</html>
