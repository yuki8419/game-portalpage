<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Shooter - WEB GAME PORTFOLIO</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Helvetica Neue", "Segoe UI", Arial, sans-serif;
      background: #0a0a0f;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .back-link {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: rgba(255, 255, 255, 0.6);
      text-decoration: none;
      font-size: 0.85rem;
      letter-spacing: 0.1em;
      transition: color 0.2s;
      z-index: 100;
    }

    .back-link:hover {
      color: #fff;
    }

    .game-container {
      position: relative;
    }

    canvas {
      display: block;
      background: #0a0a0f;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .game-ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      font-size: 0.9rem;
      letter-spacing: 0.1em;
    }

    .score, .lives {
      text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
    }

    .game-overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 10, 15, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 0.3s;
    }

    .game-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .game-overlay h1 {
      font-size: 2rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .game-overlay h2 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 1rem;
    }

    .game-overlay p {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 2rem;
      text-align: center;
      line-height: 1.8;
    }

    .start-btn {
      padding: 0.8rem 2.5rem;
      font-size: 0.9rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.4);
      cursor: pointer;
      transition: all 0.2s;
    }

    .start-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #fff;
      box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
    }

    .final-score {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 1.5rem;
    }

    .controls-hint {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 0.1em;
    }
  </style>
</head>
<body>
  <a href="../../" class="back-link">Back to Portfolio</a>

  <div class="game-container">
    <canvas id="game" width="480" height="640"></canvas>

    <div class="game-ui">
      <div class="score">SCORE: <span id="score">0</span></div>
      <div class="lives">LIVES: <span id="lives">3</span></div>
    </div>

    <div class="game-overlay" id="start-screen">
      <h1>Space Shooter</h1>
      <p>Arrow keys or WASD to move<br>Space to shoot</p>
      <button class="start-btn" id="start-btn">Start Game</button>
    </div>

    <div class="game-overlay hidden" id="game-over-screen">
      <h2>Game Over</h2>
      <p class="final-score">Score: <span id="final-score">0</span></p>
      <button class="start-btn" id="restart-btn">Play Again</button>
    </div>

    <div class="controls-hint">Arrow Keys / WASD + Space</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');

    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let player, bullets, enemies, stars, particles;
    let enemySpawnTimer = 0;
    let keys = {};

    class Player {
      constructor() {
        this.width = 40;
        this.height = 40;
        this.x = canvas.width / 2 - this.width / 2;
        this.y = canvas.height - 80;
        this.speed = 5;
        this.shootCooldown = 0;
      }

      update() {
        if (keys['ArrowLeft'] || keys['KeyA']) this.x -= this.speed;
        if (keys['ArrowRight'] || keys['KeyD']) this.x += this.speed;
        if (keys['ArrowUp'] || keys['KeyW']) this.y -= this.speed;
        if (keys['ArrowDown'] || keys['KeyS']) this.y += this.speed;

        this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
        this.y = Math.max(canvas.height / 2, Math.min(canvas.height - this.height, this.y));

        if (this.shootCooldown > 0) this.shootCooldown--;

        if (keys['Space'] && this.shootCooldown === 0) {
          bullets.push(new Bullet(this.x + this.width / 2 - 2, this.y));
          this.shootCooldown = 10;
        }
      }

      draw() {
        ctx.fillStyle = '#64c8ff';
        ctx.beginPath();
        ctx.moveTo(this.x + this.width / 2, this.y);
        ctx.lineTo(this.x, this.y + this.height);
        ctx.lineTo(this.x + this.width / 2, this.y + this.height - 10);
        ctx.lineTo(this.x + this.width, this.y + this.height);
        ctx.closePath();
        ctx.fill();

        // Engine glow
        ctx.fillStyle = '#ff6464';
        ctx.beginPath();
        ctx.moveTo(this.x + this.width / 2 - 8, this.y + this.height);
        ctx.lineTo(this.x + this.width / 2, this.y + this.height + 10 + Math.random() * 5);
        ctx.lineTo(this.x + this.width / 2 + 8, this.y + this.height);
        ctx.closePath();
        ctx.fill();
      }
    }

    class Bullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 12;
        this.speed = 8;
      }

      update() {
        this.y -= this.speed;
      }

      draw() {
        ctx.fillStyle = '#ffff64';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = 'rgba(255, 255, 100, 0.3)';
        ctx.fillRect(this.x - 2, this.y, this.width + 4, this.height + 8);
      }
    }

    class Enemy {
      constructor() {
        this.width = 30;
        this.height = 30;
        this.x = Math.random() * (canvas.width - this.width);
        this.y = -this.height;
        this.speed = 2 + Math.random() * 2;
        this.wobble = Math.random() * Math.PI * 2;
      }

      update() {
        this.y += this.speed;
        this.wobble += 0.05;
        this.x += Math.sin(this.wobble) * 0.5;
      }

      draw() {
        ctx.fillStyle = '#ff6464';
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#aa4444';
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2 - 6, this.y + this.height / 2 - 4, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2 + 6, this.y + this.height / 2 - 4, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Star {
      constructor() {
        this.reset();
        this.y = Math.random() * canvas.height;
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = -2;
        this.size = Math.random() * 2 + 0.5;
        this.speed = this.size * 0.5 + 0.5;
        this.alpha = Math.random() * 0.5 + 0.3;
      }

      update() {
        this.y += this.speed;
        if (this.y > canvas.height) this.reset();
      }

      draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.life = 30;
        this.color = color;
        this.size = Math.random() * 4 + 2;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.vx *= 0.95;
        this.vy *= 0.95;
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
        ctx.globalAlpha = 1;
      }
    }

    function createExplosion(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    function checkCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function init() {
      player = new Player();
      bullets = [];
      enemies = [];
      particles = [];
      stars = Array(50).fill(null).map(() => new Star());
      score = 0;
      lives = 3;
      enemySpawnTimer = 0;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
    }

    function update() {
      stars.forEach(star => star.update());

      player.update();

      bullets.forEach(bullet => bullet.update());
      bullets = bullets.filter(b => b.y > -b.height);

      enemySpawnTimer++;
      if (enemySpawnTimer > 60) {
        enemies.push(new Enemy());
        enemySpawnTimer = 0;
      }

      enemies.forEach(enemy => enemy.update());

      // Bullet-enemy collision
      bullets.forEach((bullet, bi) => {
        enemies.forEach((enemy, ei) => {
          if (checkCollision(bullet, enemy)) {
            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ff6464');
            bullets.splice(bi, 1);
            enemies.splice(ei, 1);
            score += 100;
            scoreEl.textContent = score;
          }
        });
      });

      // Player-enemy collision
      enemies.forEach((enemy, ei) => {
        if (checkCollision(player, enemy)) {
          createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ff6464');
          enemies.splice(ei, 1);
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver();
          }
        }

        if (enemy.y > canvas.height) {
          enemies.splice(ei, 1);
        }
      });

      particles.forEach(p => p.update());
      particles = particles.filter(p => p.life > 0);
    }

    function draw() {
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      stars.forEach(star => star.draw());
      bullets.forEach(bullet => bullet.draw());
      enemies.forEach(enemy => enemy.draw());
      particles.forEach(p => p.draw());
      player.draw();
    }

    function gameLoop() {
      if (!gameRunning) return;
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      init();
      gameRunning = true;
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverScreen.classList.remove('hidden');
    }

    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.code] = false;
    });

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Draw initial stars on start screen
    init();
    function drawStartScreen() {
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.update();
        star.draw();
      });
      if (!gameRunning) requestAnimationFrame(drawStartScreen);
    }
    drawStartScreen();
  </script>
</body>
</html>
